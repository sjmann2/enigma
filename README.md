### Enigma Self-Evaluation
**Functionality**
>-3/4: *Enigma Class with encrypt and decrypt methods successfully implemented. Encrypt/decrypt command line interfaces successfully implemented.*

**Object Oriented Programming**
>-4/4: *Students have implemented either inheritance or at least one module in a logical manner. Students can speak as to how/why inheritance and modules made sense for the given implementations, why they improve the organization of the code, and the distinction between the two.*
**Implementation of converatable module pulls out methods from enigma that convert to or from index values. This slims down the enigma file and creates a single responsibility for both enigma and convertable.**

**Ruby Conventions and Mechanics**
>- 3/4: *Code is mostly properly indented, spaced, and lines are not excessively long. Class, method, variable, and file names follow convention. Some enumerables/data structures chosen are the most efficient tool for a given job, and students can speak as to why those enumerables/data structures were chosen. At least one hash is implemented in a way that makes logical sense.*
**There are some methods that are longer than 10 lines but overall code is properly indented, spaced, and lines are not excessively long. Naming follows convention. Most enumerables are the most efficient tool for a given job. More than one hash is implemented.

**Test Driven Development**
>-3.5/4: *Mocks and/or stubs are used appropriately to ensure two or more of the following: testing is more robust (i.e., testing methods that might not otherwise be tested due to factors like randomness or user input), testing is more efficient, or that classes can be tested without relying on functionality from other classes. Students are able to speak as to how mocks and/or stubs are fulfilling the above conditions. Test coverage metrics show 100% coverage.*
**Mocks are used to test methods that are random and methods that call today's date. Test coverage not including the CLI is at 100%.**

**Version Control**
>-4/4: *Minimum 40 commits and 4 pull requests. All pull requests include related and logical chunks of functionality, and are named and documented to clearly communicate the purpose of the pull request. No commits include multiple pieces of functionality.*
**Well over 40 commits and 4 pull requests. All PRs include logical chunks of functionality and are clearly named and documented. No commits include multiple pieces of functionality.

